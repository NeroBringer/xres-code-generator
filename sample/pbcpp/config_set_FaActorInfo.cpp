
//
// generated by xrescode on 2019-06-06 22:37:19, please don't edit it
//

#include <algorithm>
#include <cstddef>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

// 禁用掉unordered_map，我们要保证mt_core中逻辑有序
#if 0 && defined(__cplusplus) && __cplusplus >= 201103L
#include <unordered_map>
#define LIBXRESLOADER_USING_HASH_MAP 1
#else

#endif

#ifdef _MSC_VER
#include <Windows.h>
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/stubs/common.h>


#include <log/log_wrapper.h>
#include <common/string_oprs.h>

#include "config_manager.h"
#include <config_set_FaActorInfo.h>

namespace excel {
    config_set_FaActorInfo::config_set_FaActorInfo() {
    }

    config_set_FaActorInfo::~config_set_FaActorInfo(){
    }

    int config_set_FaActorInfo::on_inited() {
        return 0;
    }

    int config_set_FaActorInfo::load_all() {
        return load_list("ActorInfo.files");
    }

    void config_set_FaActorInfo::clear() {
        id_max_hp_data_.clear();
    }

    int config_set_FaActorInfo::load_file(const char* file_path, size_t sz) {
        std::string file_path_s;

        if (0 == sz) {
            file_path_s = file_path;
        } else {
            file_path_s.assign(file_path, sz);
        }

        std::string content;
        if (!config_manager::me()->load_file_data(content, file_path_s)) {
            WLOGERROR("load file %s for %s failed", file_path_s.c_str(), "config_set_FaActorInfo");
            return -1;
        }

        // TODO ... 
        FaGame::FaActorInfo_Tbl outer_data;
        if (!outer_data.ParseFromString(content)) {
            WLOGERROR("parse file %s for %s(message type: %s) failed, msg: %s",
                file_path_s.c_str(), "config_set_FaActorInfo", "FaGame::FaActorInfo_Tbl",
                outer_data.InitializationErrorString().c_str()
            );
            return -2;
        }

        for (int i = 0; i < outer_data.items_size(); ++ i) {
            merge_data(std::make_shared<item_type>(outer_data.items(i)));
        }

        return 0;
    }

    int config_set_FaActorInfo::load_list(const char* file_list_path) {
        std::string content;
        if (!config_manager::me()->load_file_data(content, file_list_path)) {
            WLOGERROR("load file %s for %s failed", file_list_path, "config_set_FaActorInfo");
            return -1;
        }

        const char* line_start = content.c_str();
        const char* line_end;
        int ret = 0;
        for (; line_start < content.c_str() + content.size() && *line_start; line_start = line_end + 1) {
            line_end = line_start;

            while (*line_end && '\r' != *line_end && '\n' != *line_end) {
                ++ line_end;
            }

            std::pair<const char*, size_t> file_path = ::util::string::trim(line_start, line_end - line_start);
            if (file_path.second == 0) {
                continue;
            }

            int res = load_file(file_path.first, file_path.second);
            if (res < 0) {
                WLOGERROR("load file %s from file list %s for %s failed, res: %d",
                    file_path.first, file_list_path, "config_set_FaActorInfo", res
                );
                ret = res;
            } else if (ret >= 0) {
                ret += res;
            }
        }

        return ret;
    }

    void  config_set_FaActorInfo::merge_data(std::std::shared_ptr<item_type>) {
        // index: id_max_hp
    }
}