## -*- coding: utf-8 -*-
<%!
import time
%>
//
// generated by xrescode on ${time.strftime("%Y-%m-%d %H:%M:%S")}, please don't edit it
//

#ifdef _MSC_VER
#include <Windows.h>
#endif

#include <config/compile_optimize.h>

#include <common/file_system.h>
#include <common/string_oprs.h>
#include <log/log_wrapper.h>

#include <lock/lock_holder.h>

#include "config_manager.h"


namespace excel {
    config_manager::config_manager() : 
        override_same_version_(false),
        max_group_number_(8),
        read_file_handle_(config_manager::default_buffer_loader), 
        read_version_handle_(default_version_loader) {}

    config_manager::~config_manager() {}

    int config_manager::init() {
        return 0;
    }

    int config_manager::init_new_group() {
        std::string version;
        {
            ::util::lock::read_lock_holder<::util::lock::spin_rw_lock> rlh(handle_lock_);
            if (!read_version_handle_) {
                WLOGERROR("[EXCEL] config_manager version handle not set");
                return -1;
            }
        
            if (!read_version_handle_(version)) {
                WLOGERROR("[EXCEL] config_manager read version failed");
                return -2;
            }
        }

        do {
            // 检查版本号
            ::util::lock::read_lock_holder<::util::lock::spin_rw_lock> wlh(config_group_lock_);
            if (config_group_list_.empty()) {
                break;
            }

            if (!config_group_list_.back()) {
                break;
            }

            // 如果强制覆盖新版本号则不用检查版本号
            if (override_same_version_) {
                break;
            }

            // 版本未变化，不需要reload
            // if (0 == ::utils::string::version_compare(version.c_str(), config_group_list_.back()->version.c_str())) {
            if (version == config_group_list_.back()->version) {
                return 0;
            }
        } while (false);

        config_group_ptr_t cfg_group = std::make_shared<config_group_t>();
        if (!cfg_group) {
            WLOGERROR("[EXCEL] config_manager malloc config group failed");
            return -3;
        }
        cfg_group->version = version;

        // 加载数据走缓式评估，按需加载
        int ret = 0;
        int res = 0;
% for pb_msg in pb_set.generate_message:
%   for loader in pb_msg.loaders:
        res = cfg_group->${loader.get_cpp_public_var_name()}.on_inited();
        if (res < 0) {
            WLOGERROR("[EXCEL] ${loader.get_cpp_public_var_name()}.on_inited() failed, res: %d", res);
            ret = res;
        } else {
            if (ret >= 0) {
                ret += res;
            }

            WLOGINFO("[EXCEL] initialize %s for new config_group success", "${loader.get_cpp_public_var_name()}");
        }
%   endfor
% endfor

        if (ret >= 0) {
            ::util::lock::write_lock_holder<::util::lock::spin_rw_lock> wlh(config_group_lock_);
            config_group_list_.push_back(cfg_group);
            if (on_group_created_ && cfg_group) {
                on_group_created_(cfg_group);
            }

            if (config_group_list_.size() > 1 && config_group_list_.size() > max_group_number_) {
                config_group_ptr_t first_group = config_group_list_.front();
                config_group_list_.pop_front();

                if (on_group_destroyed_ && first_group) {
                    on_group_destroyed_(first_group);
                }
            }
        }

        return ret;
    }

    void config_manager::reset() {
        {
            ::util::lock::write_lock_holder<::util::lock::spin_rw_lock> wlh(handle_lock_);
            max_group_number_ = 8;
            override_same_version_ = false;

            read_file_handle_ = nullptr;
            read_version_handle_ = nullptr;
            on_group_created_ = nullptr;
            on_group_reload_all_ = nullptr;
            on_group_destroyed_ = nullptr;
        }

        clear();
    }

    void config_manager::clear() {
        ::util::lock::write_lock_holder<::util::lock::spin_rw_lock> wlh(config_group_lock_);
        config_group_list_.clear();
    }

    bool config_manager::load_file_data(std::string& write_to, const std::string& file_path) {
        ::util::lock::read_lock_holder<::util::lock::spin_rw_lock> rlh(handle_lock_);

        if (!read_file_handle_) {
            WLOGERROR("[EXCEL] invalid file data excel.");
            return false;
        }

        return read_file_handle_(write_to, file_path.c_str());
    }

    int config_manager::reload() {
        return init_new_group();
    }

    int config_manager::reload_all(bool del_when_failed) {
        int ret = reload();
        if (0 != ret) {
            return 0;
        }

        config_group_ptr_t cfg_group = get_current_config_group();
        if (!cfg_group) {
            WLOGERROR("[EXCEL] mutable config group failed");
            return -2;
        }

        // 触发加载所有表
        int res = 0;
% for pb_msg in pb_set.generate_message:
%   for loader in pb_msg.loaders:
        res = cfg_group->${loader.get_cpp_public_var_name()}.load_all();
        if (res < 0) {
            WLOGERROR("[EXCEL] ${loader.get_cpp_public_var_name()}.load_all() failed, res: %d", res);
            ret = res;
        } else if (ret >= 0) {
            ret += res;
        }
%   endfor
% endfor

        if (del_when_failed && ret < 0) {
            ::util::lock::write_lock_holder<::util::lock::spin_rw_lock> wlh(config_group_lock_);
            config_group_list_.pop_back();

            if (on_group_destroyed_ && cfg_group) {
                on_group_destroyed_(cfg_group);
            }
            return ret;
        }

        if (on_group_reload_all_ && cfg_group) {
            on_group_reload_all_(cfg_group);
        }

        return ret;
    }

    config_manager::read_buffer_func_t config_manager::get_buffer_loader() const { 
        ::util::lock::read_lock_holder<::util::lock::spin_rw_lock> rlh(handle_lock_);
        
        return read_file_handle_;
    }

    void config_manager::set_buffer_loader(read_buffer_func_t fn) { 
        ::util::lock::write_lock_holder<::util::lock::spin_rw_lock> wlh(handle_lock_);

        read_file_handle_ = fn; 
    }

    config_manager::read_version_func_t config_manager::get_version_loader() const { 
        ::util::lock::read_lock_holder<::util::lock::spin_rw_lock> rlh(handle_lock_);

        return read_version_handle_; 
    }

    void config_manager::set_version_loader(read_version_func_t fn) { 
        ::util::lock::write_lock_holder<::util::lock::spin_rw_lock> wlh(handle_lock_);

        read_version_handle_ = fn; 
    }

    config_manager::config_group_ptr_t config_manager::get_current_config_group() {
        {
            ::util::lock::read_lock_holder<::util::lock::spin_rw_lock> rlh(config_group_lock_);
            if (likely(!config_group_list_.empty())) {
                return *config_group_list_.rbegin();
            }
        }

        if (0 == init_new_group()) {
            ::util::lock::read_lock_holder<::util::lock::spin_rw_lock> rlh(config_group_lock_);
            if (likely(!config_group_list_.empty())) {
                return *config_group_list_.rbegin();
            }
        }

        return nullptr;
    }

    bool config_manager::default_buffer_loader(std::string& out, const char* path) {
        // if (util::file_system::is_abs_path(path)) {
        //    return util::file_system::get_file_content(out, path, true);
        //} else {
        //    return util::file_system::get_file_content(out, path, true);
        //}
        return util::file_system::get_file_content(out, path, true);
    }

    bool config_manager::default_version_loader(std::string& out) {
        out = "0";
        return true;
    }

}  // namespace excel
