## -*- coding: utf-8 -*-
<%!
import time

%><%
pb_msg_class_name = pb_msg.get_cpp_class_name()
%>
//
// generated by xrescode on ${time.strftime("%Y-%m-%d %H:%M:%S")}, please don't edit it
//

#include <algorithm>
#include <cstddef>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

// 禁用掉unordered_map，我们要保证mt_core中逻辑有序
#if 0 && defined(__cplusplus) && __cplusplus >= 201103L
#include <unordered_map>
#define LIBXRESLOADER_USING_HASH_MAP 1
#else

#endif

#ifdef _MSC_VER
#include <Windows.h>
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/stubs/common.h>


#include <log/log_wrapper.h>
#include <common/string_oprs.h>

#include "config_manager.h"
#include <${pb_msg.get_cpp_header_path()}>

namespace excel {
    ${pb_msg_class_name}::${pb_msg_class_name}() {
    }

    ${pb_msg_class_name}::~${pb_msg_class_name}(){
    }

    int ${pb_msg_class_name}::on_inited() {
        return 0;
    }

    int ${pb_msg_class_name}::load_all() {
% if pb_msg.code.file_list:
        return load_list("${pb_msg.code.file_list}");
% else:
        return load_file("${pb_msg.code.file_path}");
% endif
    }

    void ${pb_msg_class_name}::clear() {
% for code_index in pb_msg.code.indexes:
        ${code_index.name}_data_.clear();
% endfor
    }

    int ${pb_msg_class_name}::load_file(const char* file_path, size_t sz) {
        std::string file_path_s;

        if (0 == sz) {
            file_path_s = file_path;
        } else {
            file_path_s.assign(file_path, sz);
        }

        std::string content;
        if (!config_manager::me()->load_file_data(content, file_path_s)) {
            WLOGERROR("load file %s for %s failed", file_path_s.c_str(), "${pb_msg_class_name}");
            return -1;
        }

        // TODO ... 
        ${pb_msg.get_pb_outer_class_name()} outer_data;
        if (!outer_data.ParseFromString(content)) {
            WLOGERROR("parse file %s for %s(message type: %s) failed, msg: %s",
                file_path_s.c_str(), "${pb_msg_class_name}", "${pb_msg.get_pb_outer_class_name()}",
                outer_data.InitializationErrorString().c_str()
            );
            return -2;
        }

        for (int i = 0; i < outer_data.${pb_msg.code_field.name.lower()}_size(); ++ i) {
            merge_data(std::make_shared<item_type>(outer_data.${pb_msg.code_field.name.lower()}(i)));
        }

        return 0;
    }

    int ${pb_msg_class_name}::load_list(const char* file_list_path) {
        std::string content;
        if (!config_manager::me()->load_file_data(content, file_list_path)) {
            WLOGERROR("load file %s for %s failed", file_list_path, "${pb_msg_class_name}");
            return -1;
        }

        const char* line_start = content.c_str();
        const char* line_end;
        int ret = 0;
        for (; line_start < content.c_str() + content.size() && *line_start; line_start = line_end + 1) {
            line_end = line_start;

            while (*line_end && '\r' != *line_end && '\n' != *line_end) {
                ++ line_end;
            }

            std::pair<const char*, size_t> file_path = ::util::string::trim(line_start, line_end - line_start);
            if (file_path.second == 0) {
                continue;
            }

            int res = load_file(file_path.first, file_path.second);
            if (res < 0) {
                WLOGERROR("load file %s from file list %s for %s failed, res: %d",
                    file_path.first, file_list_path, "${pb_msg_class_name}", res
                );
                ret = res;
            } else if (ret >= 0) {
                ret += res;
            }
        }

        return ret;
    }

    void  ${pb_msg_class_name}::merge_data(std::std::shared_ptr<item_type>) {
% for code_index in pb_msg.code.indexes:
        // index: ${code_index.name}
% endfor
    }
}